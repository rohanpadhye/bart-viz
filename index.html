<html>
  <head>
    <title>BART System</title>
    <link rel="stylesheet" href="css/normalize.css" />
    <link rel="stylesheet" href="css/sakura.css" />
     <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
      var routes, stops, trips, stop_times, shapes, geo;
      var getTrip, getRoute, getStop, getTripStopBySequence;
      async function loadGtfs() {
        routes = await d3.csv("gtfs/routes.txt");
        stops = await d3.csv("gtfs/stops.txt");
        trips = await d3.csv("gtfs/trips.txt");
        stop_times = await d3.csv("gtfs/stop_times.txt");
        shapes = await d3.csv("gtfs/shapes.txt");

        // Create lookup functions
        var trip_dict = d3.map(trips, (d) => d.trip_id);
        var route_dict = d3.map(routes, (d) => d.route_id);
        var stop_dict = d3.map(stops, (d) => d.stop_id);
        var stop_times_dict = d3.nest().key((d) => d.trip_id).map(stop_times);
        getTrip = function(trip_id) {
          return trip_dict.get(trip_id);
        }
        getRoute = function(route_id) {
          return route_dict.get(route_id);
        }
        getStop = function(stop_id) {
          return stop_dict.get(stop_id);
        }
        getTripStopBySequence = function(trip_id, seq_id) {
          // Get a sequence of stops
          var stop_sequence = stop_times_dict.get(trip_id)
          // Array is 0-indexed but stop sequence is 1-indexed, so subtract 1
          return stop_sequence[seq_id - 1];
        }
      }

      // Global projection function
      var projection;

      /* Initializes Map projections */
      function initMapProjection(svg) {
        var viewBox = svg.attr('viewBox').split(" ");
        projection = d3.geoMercator();
        projection.center([-122.15, 37.75]);
        projection.scale(projection.scale() * 420);
        projection.translate([viewBox[2]/2, viewBox[3]/2]);
      }

      /* Project only one dimension */
      function projectionX(lon) {
        return projection([+lon, 0])[0];
      }

      /* Project only one dimension */
      function projectionY(lat) {
        return projection([0, +lat])[1];
      }

      /* Get numerical latitude for a given stop */
      function getLat(stopId) {
        return +(getStop(stopId).stop_lat);
      }

      /* Get numerical longitude for a given stop */
      function getLon(stopId) {
        return +(getStop(stopId).stop_lon);
      }

      /* Render a map of the SF bay area (via GeoJSON) on the SVG */
      var bart_geo, zoom;
      async function renderBayAreaMap(svg) {

        // Load GeoJSON downloaded from https://geodata.lib.berkeley.edu/catalog/ark28722-s7d02x
        if (!bart_geo) {
          bart_geo = await d3.json("bayarea-geo.json");
        }
        // From the GeoJSON, use only the first two features (SF + surrounding bay area lang);
        // we exclude the third feature, which is a polygon that covers the entire SF bay
        var features = bart_geo.features.slice(0, 2);

        // Create an SVG path using the initialized projection
        console.assert(projection, "Projection must be initialized");
        var geoPath = d3.geoPath().projection(projection);

        // Configure path data in SVG
        var paths = svg.select('#bay-area').selectAll('path').data(features);
        paths.join('path')
          .attr('fill', '#ccc')
          .attr('d', geoPath)
          .exit();
      }

      /* Renders the BART system map on the SVG */
      async function renderBartMap(svg) {
        console.assert(projection, "Projection must be initialized");
        console.assert(stops && routes, "GTFS must be initialized");

        var stopSize = 3;
        var stopNodes = d3.select('#bart-system').selectAll('circle').data(stops);
        var stopLabels = d3.select('#bart-system').selectAll('text').data(stops);

        // Create stop node symbols
        stopNodes.join('circle')
                 .attr('cx', (d) => projectionX(d.stop_lon))
                 .attr('cy', (d) => projectionY(d.stop_lat))
                 .attr('r', stopSize)
                 .attr('fill', '#111');

        // Label stop node symbols
        stopLabels.join('text')
                 .attr('x', (d) => projectionX(d.stop_lon) + 3)
                 .attr('y', (d) => projectionY(d.stop_lat) + 3)
                 .attr('class', 'stop-label')
                 .text((d) => d.stop_id)

         // Create routes
         var lineGenerator = d3.line()
                                   .x((d) => projectionX(d.shape_pt_lon))
                                   .y((d) => projectionY(d.shape_pt_lat));
                                   //.interpolate("linear");
         var lineShapes = d3.nest().key((d) => d.shape_id).entries(shapes);
         var linePaths = d3.select('#bart-system').selectAll('path').data(lineShapes, (d) => d.key)
         linePaths.join('path')
                  .attr('d', (d) => lineGenerator(d.values))
                  .attr('stroke', 'black')
                  .attr('stroke-width', 2)
                  .attr('fill', 'none');

      }

      // Utility function to compute time difference between stop times given in GTS,
      // e.g. "21:15:30". We need a custom routine because BART uses 
      // invalid times like "24:02:00" for post-midnight travel
      function computeGtfsTimeDiff(before, after) {
        var t1 = before.split(':');
        var t2 = after.split(':');
        var s1 = (+t1[0]) * 3600 + (+t1[1]) * 60 + (+t1[2]);
        var s2 = (+t2[0]) * 3600 + (+t2[1]) * 60 + (+t2[2]);
        return s2 - s1;
      }


      var train_icon_size = 20;
      async function updateRealTime() {
        // Get real time updates
        var msg = await d3.json("cgi-bin/realtime.cgi");
        var updates = msg.entity;

        // For each trip, set field "tripId" and "latestUpdate" for easier access later on
        var now = new Date().getTime()/1000
        for (d of updates) {
          // First, set field "tripId"
          d.tripId = d.tripUpdate.trip.tripId;

          // Now look through stop-time updates
          var stopTimeUpdates = d.tripUpdate.stopTimeUpdate;
          var idx = 0; 


          if (stopTimeUpdates[0].stopSequence == "1") {
            // This train hasn't even started, so it may just be a scheduled item
            // and not really a train. Skip it.
            continue;
          }

          // BART does not provide any meaningful delay info beyond idx = 0
          d.delay = stopTimeUpdates[0].arrival.delay;
          d.delayType = (d.delay >= 60 ? "high" : (d.delay >= 30 ? "med" : "low"));

          // Move idx up until it is slightly in the future (since we like estimates)
          while (idx + 1 < stopTimeUpdates.length && stopTimeUpdates[idx].departure_time < now) {
            idx++;
            console.log(idx);
          }

          // Set "latestUpdate" field
          d.latestUpdate = stopTimeUpdates[idx];

          // Try to get the stop info from GTFS
          var nextStopSeq = stopTimeUpdates[idx].stopSequence;
          var nextStopInfo = getTripStopBySequence(d.tripId, nextStopSeq);
          var prevStopInfo = nextStopSeq > 1 ? getTripStopBySequence(d.tripId, nextStopSeq - 1) : null;

          // If there is another stop after "idx", and if
          // if the train already left "idx", then interpolate lat/long
          if (prevStopInfo) {
            // Calculate fraction of remaining trip as (trip_time_elapsed)/(trip_duration)
            var timeToNextStop = stopTimeUpdates[idx].arrival.time - now;
            var stopTravelTime = computeGtfsTimeDiff(prevStopInfo.departure_time, nextStopInfo.arrival_time);
            var fracRemaining = timeToNextStop / stopTravelTime;

            // Clip fracRemaining to [-1, 1]
            if (fracRemaining < 0) {
              fracRemaining = 0.0;
            }
            if (fracRemaining > 1) {
              fracRemaining = 1.0;
            }


            // Estimate latest value for lat/long using linear interpolation
            d.latestLon = getLon(prevStopInfo.stop_id) * fracRemaining + 
              getLon(nextStopInfo.stop_id) * (1 - fracRemaining);
            d.latestLat = getLat(prevStopInfo.stop_id) * fracRemaining + 
              getLat(nextStopInfo.stop_id) * (1 - fracRemaining);
            // console.log(frac);
            // console.log(d.latestLon);
            // console.log(d.latestLat);
            // console.log("\n\n\n");
          } else {
            d.latestLon = getLon(stopTimeUpdates[idx].stopId);
            d.latestLat = getLat(stopTimeUpdates[idx].stopId);
          }
        }

        // Filter out updates to keep only those that have a "latestUpdate"
        updates = updates.filter(d => d.latestUpdate);

        // Sort in descending order of delays, and then by ascending order of arrival time
        updates.sort((a, b) => a.latestUpdate.arrival.time - b.latestUpdate.arrival.time);
        updates.sort((a, b) => b.latestUpdate.arrival.delay - a.latestUpdate.arrival.delay);

        // Update header
        d3.select("#trip-count").text("(" + updates.length + ")");

        // Update table
        var rows = d3.select('#current-table tbody')
          .selectAll('tr')
          .data(updates, (d) => d.tripId)
          .join(enter => enter.append('tr')
            .call(row => row.append('td').attr('class', 'dest'))
            .call(row => row.append('td').attr('class', 'stop'))
            .call(row => row.append('td').attr('class', 'time'))
            .call(row => row.append('td').attr('class', 'delay')))
          .attr('id', d => 'row-'+d.tripId)
          .on('mouseover', (d) => highlightTrain(d))
          .on('click', (d) => selectTrain(d))
          .on('mouseout', unhighlightTrain)
          .order();
          
        rows.selectAll('td.dest')
          .text((d) => getTrip(d.tripId).trip_headsign)
          .attr('title', (d) => getTrip(d.tripId).trip_headsign)
          .style('white-space', 'nowrap')
          .style('overflow', 'hidden')
          .style('text-overflow', 'ellipsis');
        rows.selectAll('td.stop')
            .text((d) => d.latestUpdate.stopId)
            .attr('title', (d) => getStop(d.latestUpdate.stopId).stop_name);
        rows.selectAll('td.time').text((d) => { 
          var time = +d.latestUpdate.arrival.time;
          var date = new Date(time*1000);
          return date.toLocaleTimeString("en-us", {
            hour12: false,
            formatMatcher: "basic",
            timeZone: "America/Los_Angeles"
          });
        });
        rows.selectAll('td.delay').text(d => { 
          var delay = d.delay;
          if (delay == 0) { 
            return "0s"; 
          } else { 
            // Format delay (e.g. '+1m2s' or '+30s' or '-5s')
            if (delay > 0) {
              str = "+";
            } else {
              str = "-";
            }
            delay = Math.abs(delay)
            if (delay > 60) {
              str += Math.floor(delay/60) + "m ";
              delay = delay % 60;
            }
            str += delay + "s";
            return str; 
          }
        }).classed('delay-high', d => d.delayType == 'high')
        .classed('delay-med', d => d.delayType == 'med')
        .classed('delay-low', d => d.delayType == 'low');

        var trains = d3.select('#bart-trains').selectAll('image')
                       .data(updates, (d) => d.tripId);

        trains.transition()
              .duration(50)
              .attr('x', (d) => projectionX(d.latestLon) - train_icon_size/2)
              .attr('y', (d) => projectionY(d.latestLat) - train_icon_size/2);


        trains.enter().append('image')
              .attr('xlink:href', d => 'img/train-'+d.delayType+'.svg')
              .attr('width', train_icon_size)
              .attr('height', train_icon_size)
              .attr('x', (d) => projectionX(d.latestLon) - train_icon_size/2)
              .attr('y', (d) => projectionY(d.latestLat) - train_icon_size/2)
              .on('mouseover', (d) => highlightTrain(d))
              .on('click', (d) => selectTrain(d))
              .on('mouseout', unhighlightTrain);

        /* Refresh the bar chart */
        renderBarChart(updates);

        /* Draw a border around a train icon */
        function highlightTrain(d) {
          unhighlightTrain();

          var strokeWidth = 3;
          var rectSize = train_icon_size + 2 * strokeWidth;
          d3.select('#bart-trains')
            .append('rect')
            .attr('width', rectSize)
            .attr('height', rectSize)
            .attr('x', projectionX(d.latestLon) - rectSize/2)
            .attr('y', projectionY(d.latestLat) - rectSize/2)
            .attr('fill', 'none')
            .attr('stroke', 'black')//"#" + getRoute(getTrip(d.tripId).route_id).route_color)
            .attr('stroke-width', strokeWidth);

          // Highlight table row
          d3.select('#row-'+d.tripId).classed('highlight', true);
        }

        function unhighlightTrain() {
          highlightedTrain = d3.select('#bart-trains').selectAll('rect').remove();
          d3.selectAll('#current-table tr').classed('highlight', false);
        }
         
        /* Show some info about a train */ 
        function selectTrain(d) {
          console.log(d.tripId);
        }
      }

      function renderTrains(svg) {
        var trains = svg.select('#bart-trains').selectAll('image');

        trains.attr('x', (d) => projectionX(d.latestLon) - train_icon_size/2)
              .attr('y', (d) => projectionY(d.latestLat) - train_icon_size/2);
      }

      function renderBarChart(updates) {
        var svg = d3.select('#delay-categories');
        var viewBox = svg.attr('viewBox').split(" ");
        var width = +viewBox[2];
        var height = +viewBox[3];
        var bars = svg.select('#bar-chart #bars');
        var xAxis = svg.select('#bar-chart #x-axis');
        var yAxis = svg.select('#bar-chart #y-axis');

        var data = []
        var delayTypes = ['low', 'med', 'high'];
        var delayTypeCounts = delayTypes.map((t) => {
          return {
            'label': t,
            'class': 'delay-'+t,
            'count': updates.filter(d => d.delayType == t).length
          }});

        var margin = ({top: 10, right: 10, bottom: 15, left: 20});
        var x = d3.scaleBand()
                  .domain(delayTypes)
                  .range([margin.left, width - margin.right]);

        var y = d3.scaleLinear()
                  .domain([0, d3.max(delayTypeCounts, d => d.count)]).nice()
                  .range([height - margin.bottom, margin.top]);

        var xAxisTransform = g => g
          .attr("transform", `translate(0,${height - margin.bottom})`)
          .call(d3.axisBottom(x).tickSizeOuter(0));
        xAxis.call(xAxisTransform)
             .attr("font-size", "5");

        var yAxisTransform = g => g
          .attr("transform", `translate(${margin.left},0)`)
          .call(d3.axisLeft(y))
          .call(g => g.select(".domain").remove());
        yAxis.call(yAxisTransform)
             .attr("font-size", "5");

        bars.selectAll('rect').data(delayTypeCounts)
            .join('rect')
            .attr('x', d => x(d.label))
            .attr('y', d => y(d.count))
            .attr('height', d => y(0) - y(d.count))
            .attr('width', x.bandwidth())
            .attr('class', d => 'delay-' + d.label + '-bar'); 
      }

      function updateLoop() {
        // Fetch real-time data and update all views
        updateRealTime();

        // Schedule this function for continuous updates
        setTimeout(updateLoop, 5000);
      }

      async function init() {
        // Load GTFS csv files into global vars
        // We await for this call because other stuff depends on GTFS
        await loadGtfs();

        // This is the SVG where we will render the map
        var svg = d3.select('#map');

        initMapProjection(svg);

        // Render Bay area map
        await renderBayAreaMap(svg);

        // Render BART map
        await renderBartMap(svg);



        // Make the map zoomable
        var initialScale = projection.scale();
        var [initialX, initialY] = projection.translate();
        zoom = d3.zoom()
                     zoom.on("zoom", () => {
                      // Update map projection based on zoom event
                      var transform = d3.event.transform;
                      projection.translate([transform.x + initialX, transform.y + initialY]);
                      projection.scale(initialScale * transform.k);

                      // Re-render map, system, and trains
                      renderBayAreaMap(svg);
                      renderBartMap(svg);
                      renderTrains(svg);
                    });
        svg.call(zoom);

        // Show real-time tab
        showTab('realtime');

        // End by firing off the real-time updates
        updateLoop();
      } 

      function resetZoom() {
        zoom.transform(d3.select('#map'), d3.zoomIdentity);
        renderBayAreaMap(svg);
        renderBartMap(svg);
        renderTrains(svg);
      }
        
      function showTab(id) {
        // First, hide all tab contents and make all tab headers boring
        d3.selectAll(".tab-content").style('display', 'none');
        d3.selectAll(".tab-header").classed('tab-active', false);
        // Then, show the selected tab
        d3.select("#tab-" + id + "-content").style('display', 'block');
        d3.select("#tab-" + id + "-header").classed('tab-active', true);
      }
        
    </script>
    <style type="text/css">
      * { box-sizing: border-box; }


      #tabs {
        text-align: center;
      }

      .tab-header {
        margin-left: 2em;
        margin-right: 2em;
        font-size: 1.5em;
      }

      .tab-active { 
        background-color: #982c61;
        border-color: #982c61;
        color: #f9f9f9;
        outline: 0;
      }

      .tab-content {
        display: none; /* Initial */
        text-align: center;
        margin: auto;
      }

      #map {
        border: 1px solid #ccc;
        cursor: grab;
      }

      #map:active {
        cursor: grabbing;
      }

      .stop-label {
        font-weight: bold;
        font-size: 0.8em;
      }

      .grid {
        display: table;
        width: 100%;
        border-spacing:.5em;
        /* height: 60em; */
      }

      @media (min-width: 80em) {
        .col {
          display: table-cell;
          border: #666 1px solid;
          vertical-align: top;
          padding: 1em;
        }
        .sides {
          width: 25%;
        }
        .middle {
          width: 50%;
          padding: 0;
        }
      }

      #current-div {
        height: 40em;
        overflow-y: scroll;
      }

      #current-table {
        font-size: 0.9em;
      }

      #current-table tr:hover {
        cursor: pointer;
      }

      #current-table tr.highlight {
        background-color: #ccc;
      }

      tr.stripe {
        /* background-color: #ccc; */
      }

      svg #bart-trains image:hover {
        cursor: pointer;
      }

      .delay-high {
        color: red;
      }

      .delay-high-bar {
        fill: red;
      }

      .delay-med {
        color: brown;
      }

      .delay-med-bar {
        fill: brown;
      }

      .delay-low {
        color: teal;
      }

      .delay-low-bar {
        fill: teal;
      }

    </style>
  </head>
  <body onload="init()">
    <h1>BART Delays</h1>

    <div id="tabs">
      <div id="tab-headers">
        <button class="tab-header" id="tab-realtime-header" onclick="showTab('realtime')">Real-time delays</button>
        <button class="tab-header" id="tab-daily-header" onclick="showTab('daily')">Delays by time of day</button>
        <button class="tab-header" id="tab-cross-header" onclick="showTab('cross')">Delays by station</button>
      </div>

      <div id="tab-contents">
        <div class="tab-content" id="tab-realtime-content">
        	<div class="grid">
            <div class="col sides">
              <h2>Current Trips <span id="trip-count"></span></h2>
              <div id="current-div">
                <table id="current-table" style="table-layout: fixed;">
                  <thead><th>Line</th><th>Stop</th><th>Arrival</th><th>Delay</th></thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
            <div class="col middle">
              <svg id="map" width="100%" height="600" viewBox="0 0 800 800">
                <g id="bay-area" />
                <g id="bart-system"></g>
                <g id="bart-trains"></g>
                <g id="bart-alerts"></g>
              </svg>
            </div>
            <div class="col sides">
              <h2>Trains Delayed</h2>
              <svg id="delay-categories" width="100%" height="250" viewBox="0 0 100 100">
                <g id="bar-chart"> 
                  <g id="bars" stroke="black" />
                  <g id="x-axis" />
                  <g id="y-axis" />
                </g>
              </svg>
              <h3>Legend</h3>
              <dl>
                <dt class="delay-low">low</dt>
                <dd>Less than 30 seconds delayed (includes running trains with no delay). This is normal operation.</dd>
                <dt class="delay-med">med</dt>
                <dd>30-60 seconds delayed. Trains with medium delay are expected to catch up by making time before their trip ends.</dd>
                <dt class="delay-high">high</dt>
                <dd>More than 1 minute delay. High delay indicates severe issues with the system that can cause long-term cascading backups.</dd>
              </dl>
            </div>
          </div>
        </div>
        <div class="tab-content" id="tab-daily-content">Daily!!</div>
        <div class="tab-content" id="tab-cross-content">
<script type='text/javascript' src='https://us-west-2b.online.tableau.com/javascripts/api/viz_v1.js'></script><div class='tableauPlaceholder' style='width: 1000px; height: 827px;'><object class='tableauViz' width='1000' height='827' style='display:none;'><param name='host_url' value='https%3A%2F%2Fus-west-2b.online.tableau.com%2F' /> <param name='embed_code_version' value='3' /> <param name='site_root' value='&#47;t&#47;introtodatavisualizationfall2018' /><param name='name' value='bart_New_Dashboardv5&#47;Dashboard1b' /><param name='tabs' value='no' /><param name='toolbar' value='yes' /><param name='showAppBanner' value='false' /><param name='filter' value='iframeSizedToWindow=true' /></object></div>
        </div>
      </div>
    </div>

  </body>
</html>