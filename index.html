<html>
	<head>
		<title>BART System</title>
    <link rel="stylesheet" href="css/normalize.css" />
    <link rel="stylesheet" href="css/sakura.css" />
	 	<script src="https://d3js.org/d3.v5.min.js"></script>
		<script>
			var routes, stops, trips, stop_times, shapes, geo;
			var getTrip, getRoute;
			async function loadGtfs() {
				routes = await d3.csv("gtfs/routes.txt");
				stops = await d3.csv("gtfs/stops.txt");
				trips = await d3.csv("gtfs/trips.txt");
				stop_times = await d3.csv("gtfs/stop_times.txt");
				shapes = await d3.csv("gtfs/shapes.txt");

				// Create lookup functions
				var trip_dict = d3.map(trips, (d) => d.trip_id);
				var route_dict = d3.map(routes, (d) => d.route_id);
				var stop_dict = d3.map(stops, (d) => d.stop_id);
				getTrip = function(trip_id) {
					return trip_dict.get(trip_id);
				}
				getRoute = function(route_id) {
					return route_dict.get(route_id);
				}
				getStop = function(stop_id) {
					return stop_dict.get(stop_id);
				}
			}

			// Global projection function
			var projection;

			/* Initializes Map projections */
			function initMapProjection(svg) {
				var viewBox = svg.attr('viewBox').split(" ");
				projection = d3.geoMercator();
				projection.center([-122.15, 37.75]);
				projection.scale(projection.scale() * 420);
				projection.translate([viewBox[2]/2, viewBox[3]/2]);
			}

			/* Project only one dimension */
			function projectionX(lon) {
				return projection([+lon, 0])[0];
			}

			/* Project only one dimension */
			function projectionY(lat) {
				return projection([0, +lat])[1];
			}

			/* Get numerical latitude for a given stop */
			function getLat(stopId) {
				return +(getStop(stopId).stop_lat);
			}

			/* Get numerical longitude for a given stop */
			function getLon(stopId) {
				return +(getStop(stopId).stop_lon);
			}

			/* Render a map of the SF bay area (via GeoJSON) on the SVG */
			async function renderBayAreaMap(svg) {

				// Load GeoJSON downloaded from https://geodata.lib.berkeley.edu/catalog/ark28722-s7d02x
				var geo = await d3.json("bayarea-geo.json");

				// From the GeoJSON, use only the first two features (SF + surrounding bay area lang);
				// we exclude the third feature, which is a polygon that covers the entire SF bay
				var features = geo.features.slice(0, 2);

				// Create an SVG path using the initialized projection
				console.assert(projection, "Projection must be initialized");
				var geoPath = d3.geoPath().projection(projection);

				// Configure path data in SVG
				var paths = svg.select('#bay-area').selectAll('path').data(features);
				paths.enter()
					.append('path')
					.attr('fill', '#ccc')
					.attr('d', geoPath)
					.exit();
			}

			/* Renders the BART system map on the SVG */
			async function renderBartMap(svg) {
				console.assert(projection, "Projection must be initialized");
				console.assert(stops && routes, "GTFS must be initialized");

				var stopSize = 3;
				var stopNodes = d3.select('#bart-system').selectAll('circle').data(stops);

				// Create stop node symbols
				stopNodes.enter()
				         .append('circle')
				         .attr('cx', (d) => projectionX(d.stop_lon))
				         .attr('cy', (d) => projectionY(d.stop_lat))
				         .attr('r', stopSize)
				         .attr('fill', '#111');

				// Label stop node symbols
				stopNodes.enter()
				         .append('text')
				         .attr('x', (d) => projectionX(d.stop_lon) + 3)
				         .attr('y', (d) => projectionY(d.stop_lat) + 3)
				         .attr('class', 'stop label')
				         .text((d) => d.stop_id)

				 // Create routes
				 var lineGenerator = d3.line()
				                           .x((d) => projectionX(d.shape_pt_lon))
				                           .y((d) => projectionY(d.shape_pt_lat));
				                           //.interpolate("linear");
				 var lineShapes = d3.nest().key((d) => d.shape_id).entries(shapes);
				 var linePaths = d3.select('#bart-system').selectAll('path').data(lineShapes, (d) => d.key)
				 linePaths.enter()
				          .append('path')
				          .attr('d', (d) => lineGenerator(d.values))
				          .attr('stroke', 'black')
				          .attr('stroke-width', 2)
				          .attr('fill', 'none');

			}



			async function updateRealTime() {
				// Get real time updates
				var msg = await d3.json("cgi-bin/bart-realtime-get-json");
				var updates = msg.entity;


				// For each trip, set field "tripId" and "latestUpdate" for easier access later on
				var now = new Date().getTime()/1000
				for (d of updates) {
					// First, set field "tripId"
					d.tripId = d.tripUpdate.trip.tripId;

					// Now look through stop-time updates
					var stopTimeUpdates = d.tripUpdate.stopTimeUpdate;
					var idx = 0; 

					// ... TODO: Find the best idx ...
					if (stopTimeUpdates[0].stopSequence == "1") {
						// This train hasn't even started, so it may just be a scheduled item
						// and not really a train. Skip it.
						continue;
					}

					// Set "latestUpdate" field
					d.latestUpdate = stopTimeUpdates[idx];

					// If there is another stop after "idx", and if
					// if the train already left "idx", then interpolate lat/long
					var tripTimeElapsed = (now - stopTimeUpdates[idx].departure.time);
					if (idx + 1 < stopTimeUpdates.length && tripTimeElapsed > 0) {
						// Calculate fraction of trip as (trip_time_elapsed)/(trip_duration)
						var scheduledDepartureTime = stopTimeUpdates[idx].departure.time - stopTimeUpdates[idx].departure.delay;
						var scheduledArrivalTime = stopTimeUpdates[idx+1].arrival.time - stopTimeUpdates[idx+1].arrival.delay;
						var tripDuration = scheduledArrivalTime - scheduledDepartureTime;
						var frac = tripTimeElapsed / tripDuration;
						console.assert(tripDuration >= 0, "Trip duration must be positive: " + tripDuration);
						console.assert(frac >= 0, "Fraction must be >= 0: " + frac);
						console.assert(frac <= 1, "Fraction must be <= 1: " + frac);

						// Estimate latest value for lat/long using linear interpolation
						d.latestLon = getLon(stopTimeUpdates[idx].stopId) * frac + 
							getLon(stopTimeUpdates[idx+1].stopId) * (1 - frac);
						d.latestLat = getLat(stopTimeUpdates[idx].stopId) * frac + 
							getLat(stopTimeUpdates[idx+1].stopId) * (1 - frac);
						// console.log(frac);
						// console.log(d.latestLon);
						// console.log(d.latestLat);
						// console.log("\n\n\n");
					} else {
						d.latestLon = getLon(stopTimeUpdates[idx].stopId);
						d.latestLat = getLat(stopTimeUpdates[idx].stopId);
					}
				}

				// Filter out updates to keep only those that have a "latestUpdate"
				updates = updates.filter(d => d.latestUpdate);

				// Sort in descending order of delays, and then by ascending order of arrival time
				updates.sort((a, b) => a.latestUpdate.arrival.time - b.latestUpdate.arrival.time);
				updates.sort((a, b) => b.latestUpdate.arrival.delay - a.latestUpdate.arrival.delay);

				var rows = d3.select('#current-tab tbody')
				  .selectAll('tr')
				  .data(updates, (d) => d.tripUpdate.trip.tripId)
				  .join(enter => enter.append('tr')
				  	.call(row => row.append('td').attr('class', 'dest'))
				  	.call(row => row.append('td').attr('class', 'stop'))
				  	.call(row => row.append('td').attr('class', 'time'))
				  	.call(row => row.append('td').attr('class', 'delay'))
				    .style('font-weight', 'bold')
				    .style('background-color', (d) => getRoute(getTrip(d.tripId).route_id).route_color))
				    .on('mouseover', (d) => highlightTrain(d))
				    .on('mouseout', unhighlightTrain);
				  
				rows.selectAll('td.dest')
				  .text((d) => getTrip(d.tripId).trip_headsign)
				  .attr('title', (d) => getTrip(d.tripId).trip_headsign)
				  .style('white-space', 'nowrap')
				  .style('overflow', 'hidden')
				  .style('text-overflow', 'ellipsis');
				rows.selectAll('td.stop').text((d) => d.latestUpdate.stopId);
				rows.selectAll('td.time').text((d) => { 
					var time = +d.latestUpdate.arrival.time;
					var date = new Date(time*1000);
					return date.toLocaleTimeString("en-us", {
						hour12: false,
						formatMatcher: "basic",
						timeZone: "America/Los_Angeles"
					});
				});
				rows.selectAll('td.delay').text((d) => { 
					var delay = d.latestUpdate.arrival.delay;
					if (delay == 0) { 
						return "-"; 
					} else { 
						// Format delay (e.g. '+1m2s' or '+30s' or '-5s')
						if (delay > 0) {
							str = "+";
						} else {
							str = "-";
						}
						delay = Math.abs(delay)
						if (delay > 60) {
							str += Math.floor(delay/60) + "m ";
							delay = delay % 60;
						}
						str += delay + "s";
						return str; 
					}
				});

				var image_icon_size = 20;
				var trains = d3.select('#bart-trains').selectAll('image')
				               .data(updates, (d) => d.tripId);

				trains.transition()
				      .duration(500)
              .attr('x', (d) => projectionX(d.latestLon) - image_icon_size/2)
              .attr('y', (d) => projectionY(d.latestLat) - image_icon_size/2);


				trains.enter().append('image')
              .attr('xlink:href', 'img/train.svg')
              .attr('width', image_icon_size)
              .attr('height', image_icon_size)
              .attr('x', (d) => projectionX(d.latestLon) - image_icon_size/2)
              .attr('y', (d) => projectionY(d.latestLat) - image_icon_size/2);

  			/* Draw a border around a train icon */
        function highlightTrain(d) {
        	unhighlightTrain();

					var strokeWidth = 5;
					var rectSize = image_icon_size + 2 * strokeWidth;
					d3.select('#bart-trains')
				    .append('rect')
				    .attr('width', rectSize)
				    .attr('height', rectSize)
				    .attr('x', projectionX(d.latestLon) - rectSize/2)
				    .attr('y', projectionY(d.latestLat) - rectSize/2)
				    .attr('fill', 'none')
				    .attr('stroke', "#" + getRoute(getTrip(d.tripId).route_id).route_color)
					  .attr('stroke-width', strokeWidth);
        }

        function unhighlightTrain() {
        	highlightedTrain = d3.select('#bart-trains').selectAll('rect').remove();
        }
				 
			}

			function updateLoop() {
				// Fetch real-time data and update all views
				updateRealTime();

				// Schedule this function for continuous updates
				setTimeout(updateLoop, 5000);
			}

			async function init() {
				// Load GTFS csv files into global vars
				// We await for this call because other stuff depends on GTFS
				await loadGtfs();

				// This is the SVG where we will render the map
				var svg = d3.select('#map');

				initMapProjection(svg);

				// Render Bay area map
				renderBayAreaMap(svg);

				// Render BART map
				renderBartMap(svg);

				// End by firing off the real-time updates
				updateLoop();
			} 
        
        
		</script>
		<style type="text/css">
			* { box-sizing: border-box; }

			#map {
				border: 1px solid #ccc;
			}

			.label {
				font-size: 0.8em;
			}

			.stop {
				font-weight: bold;
			}

			.grid{
  			display: table;
  			width: 100%;
  			border-spacing:.5em;
  			height: 50em;
			}
			@media (min-width: 80em) {
				.col {
	    		display: table-cell;
	    		border: #666 1px solid;
	    		vertical-align: top;
	    		padding: 1em;
				}
				.sides {
					width: 25%;
				}
				.middle {
					width: 50%;
					padding: 0;
				}
			}
			#current-div {
				height: 40em;
    		overflow-y: scroll;
			}
			#current-tab {
				font-size: 0.9em;
			}
			thead {
				font-weight: bold;
			}
		</style>
	</head>
	<body onload="init()">
		<h1>BART: System Information</h1>
		<div class="grid">
			<div class="col sides">
				<h2>Current Trips</h2>
				<div id="current-div">
					<table id="current-tab" style="table-layout: fixed;">
						<thead><td>Trip</td><td>Stop</td><td>Arrival</td><td>Delay</td></thead>
						<tbody></tbody>
					</table>
			  </div>
			</div>
			<div class="col middle">
				<svg id="map" width="100%" height="100%" viewBox="0 0 800 800">
					<g id="bay-area" />
					<g id="bart-system"></g>
					<g id="bart-trains"></g>
					<g id="bart-alerts"></g>
				</svg>
			</div>
			<div class="col sides">
				<h2>Station Info</h2>
				<p>More stuff to be added...</p>
			</div>
		</div>
		<h2>Statistics</h2>
		<p>More stuff to be added...</p>
	</body>
</html>