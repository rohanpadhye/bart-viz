<html>
  <head>
    <title>BART System</title>
    <link rel="stylesheet" href="css/normalize.css" />
    <link rel="stylesheet" href="css/sakura.css" />
     <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
      var routes, stops, trips, stop_times, shapes, geo;
      var getTrip, getRoute, getStop, getTripStopBySequence;
      async function loadGtfs() {
        routes = await d3.csv("gtfs/routes.txt");
        stops = await d3.csv("gtfs/stops.txt");
        trips = await d3.csv("gtfs/trips.txt");
        stop_times = await d3.csv("gtfs/stop_times.txt");
        shapes = await d3.csv("gtfs/shapes.txt");

        // Create lookup functions
        var trip_dict = d3.map(trips, (d) => d.trip_id);
        var route_dict = d3.map(routes, (d) => d.route_id);
        var stop_dict = d3.map(stops, (d) => d.stop_id);
        var stop_times_dict = d3.nest().key((d) => d.trip_id).map(stop_times);
        getTrip = function(trip_id) {
          return trip_dict.get(trip_id);
        }
        getRoute = function(route_id) {
          return route_dict.get(route_id);
        }
        getStop = function(stop_id) {
          return stop_dict.get(stop_id);
        }
        getTripStopBySequence = function(trip_id, seq_id) {
        	// Get a sequence of stops
        	var stop_sequence = stop_times_dict.get(trip_id)
        	// Array is 0-indexed but stop sequence is 1-indexed, so subtract 1
        	return stop_sequence[seq_id - 1];
        }
      }

      // Global projection function
      var projection;

      /* Initializes Map projections */
      function initMapProjection(svg) {
        var viewBox = svg.attr('viewBox').split(" ");
        projection = d3.geoMercator();
        projection.center([-122.15, 37.75]);
        projection.scale(projection.scale() * 420);
        projection.translate([viewBox[2]/2, viewBox[3]/2]);
      }

      /* Project only one dimension */
      function projectionX(lon) {
        return projection([+lon, 0])[0];
      }

      /* Project only one dimension */
      function projectionY(lat) {
        return projection([0, +lat])[1];
      }

      /* Get numerical latitude for a given stop */
      function getLat(stopId) {
        return +(getStop(stopId).stop_lat);
      }

      /* Get numerical longitude for a given stop */
      function getLon(stopId) {
        return +(getStop(stopId).stop_lon);
      }

      /* Render a map of the SF bay area (via GeoJSON) on the SVG */
      async function renderBayAreaMap(svg) {

        // Load GeoJSON downloaded from https://geodata.lib.berkeley.edu/catalog/ark28722-s7d02x
        var geo = await d3.json("bayarea-geo.json");

        // From the GeoJSON, use only the first two features (SF + surrounding bay area lang);
        // we exclude the third feature, which is a polygon that covers the entire SF bay
        var features = geo.features.slice(0, 2);

        // Create an SVG path using the initialized projection
        console.assert(projection, "Projection must be initialized");
        var geoPath = d3.geoPath().projection(projection);

        // Configure path data in SVG
        var paths = svg.select('#bay-area').selectAll('path').data(features);
        paths.enter()
          .append('path')
          .attr('fill', '#ccc')
          .attr('d', geoPath)
          .exit();
      }

      /* Renders the BART system map on the SVG */
      async function renderBartMap(svg) {
        console.assert(projection, "Projection must be initialized");
        console.assert(stops && routes, "GTFS must be initialized");

        var stopSize = 3;
        var stopNodes = d3.select('#bart-system').selectAll('circle').data(stops);

        // Create stop node symbols
        stopNodes.enter()
                 .append('circle')
                 .attr('cx', (d) => projectionX(d.stop_lon))
                 .attr('cy', (d) => projectionY(d.stop_lat))
                 .attr('r', stopSize)
                 .attr('fill', '#111');

        // Label stop node symbols
        stopNodes.enter()
                 .append('text')
                 .attr('x', (d) => projectionX(d.stop_lon) + 3)
                 .attr('y', (d) => projectionY(d.stop_lat) + 3)
                 .attr('class', 'stop label')
                 .text((d) => d.stop_id)

         // Create routes
         var lineGenerator = d3.line()
                                   .x((d) => projectionX(d.shape_pt_lon))
                                   .y((d) => projectionY(d.shape_pt_lat));
                                   //.interpolate("linear");
         var lineShapes = d3.nest().key((d) => d.shape_id).entries(shapes);
         var linePaths = d3.select('#bart-system').selectAll('path').data(lineShapes, (d) => d.key)
         linePaths.enter()
                  .append('path')
                  .attr('d', (d) => lineGenerator(d.values))
                  .attr('stroke', 'black')
                  .attr('stroke-width', 2)
                  .attr('fill', 'none');

      }

      // Utility function to compute time difference between stop times given in GTS,
      // e.g. "21:15:30". We need a custom routine because BART uses 
      // invalid times like "24:02:00" for post-midnight travel
      function computeGtfsTimeDiff(before, after) {
      	var t1 = before.split(':');
      	var t2 = after.split(':');
      	var s1 = (+t1[0]) * 3600 + (+t1[1]) * 60 + (+t1[2]);
      	var s2 = (+t2[0]) * 3600 + (+t2[1]) * 60 + (+t2[2]);
      	return s2 - s1;
      }


      async function updateRealTime() {
        // Get real time updates
        var msg = await d3.json("cgi-bin/bart-realtime-get-json");
        var updates = msg.entity;


        // For each trip, set field "tripId" and "latestUpdate" for easier access later on
        var now = new Date().getTime()/1000
        for (d of updates) {
          // First, set field "tripId"
          d.tripId = d.tripUpdate.trip.tripId;

          // Now look through stop-time updates
          var stopTimeUpdates = d.tripUpdate.stopTimeUpdate;
          var idx = 0; 


          if (stopTimeUpdates[0].stopSequence == "1") {
            // This train hasn't even started, so it may just be a scheduled item
            // and not really a train. Skip it.
            continue;
          }




          // BART does not provide any meaningful delay info beyond idx = 0
          d.delay = stopTimeUpdates[0].delay;

          // Move idx up until it is slightly in the future (since we like estimates)
          while (idx + 1 < stopTimeUpdates.length && stopTimeUpdates[idx].departure_time < now) {
          	idx++;
          	console.log(idx);
          }

          // Set "latestUpdate" field
          d.latestUpdate = stopTimeUpdates[idx];

          // Try to get the stop info from GTFS
          var nextStopSeq = stopTimeUpdates[idx].stopSequence;
          var nextStopInfo = getTripStopBySequence(d.tripId, nextStopSeq);
          var prevStopInfo = nextStopSeq > 1 ? getTripStopBySequence(d.tripId, nextStopSeq - 1) : null;

          // If there is another stop after "idx", and if
          // if the train already left "idx", then interpolate lat/long
          if (prevStopInfo) {
            // Calculate fraction of remaining trip as (trip_time_elapsed)/(trip_duration)
	          var timeToNextStop = stopTimeUpdates[idx].arrival.time - now;
          	var stopTravelTime = computeGtfsTimeDiff(prevStopInfo.departure_time, nextStopInfo.arrival_time);
            var fracRemaining = timeToNextStop / stopTravelTime;

            // Clip fracRemaining to [-1, 1]
            if (fracRemaining < 0) {
            	fracRemaining = 0.0;
            }
            if (fracRemaining > 1) {
            	fracRemaining = 1.0;
            }


            // Estimate latest value for lat/long using linear interpolation
            d.latestLon = getLon(prevStopInfo.stop_id) * fracRemaining + 
              getLon(nextStopInfo.stop_id) * (1 - fracRemaining);
            d.latestLat = getLat(prevStopInfo.stop_id) * fracRemaining + 
              getLat(nextStopInfo.stop_id) * (1 - fracRemaining);
            // console.log(frac);
            // console.log(d.latestLon);
            // console.log(d.latestLat);
            // console.log("\n\n\n");
          } else {
            d.latestLon = getLon(stopTimeUpdates[idx].stopId);
            d.latestLat = getLat(stopTimeUpdates[idx].stopId);
          }
        }

        // Filter out updates to keep only those that have a "latestUpdate"
        updates = updates.filter(d => d.latestUpdate);

        // Sort in descending order of delays, and then by ascending order of arrival time
        updates.sort((a, b) => a.latestUpdate.arrival.time - b.latestUpdate.arrival.time);
        updates.sort((a, b) => b.latestUpdate.arrival.delay - a.latestUpdate.arrival.delay);

        var rows = d3.select('#current-tab tbody')
          .selectAll('tr')
          .data(updates, (d) => d.tripUpdate.trip.tripId)
          .join(enter => enter.append('tr')
            .call(row => row.append('td').attr('class', 'dest'))
            .call(row => row.append('td').attr('class', 'stop'))
            .call(row => row.append('td').attr('class', 'time'))
            .call(row => row.append('td').attr('class', 'delay'))
            .style('font-weight', 'bold')
            .style('background-color', (d) => getRoute(getTrip(d.tripId).route_id).route_color))
            .on('mouseover', (d) => highlightTrain(d))
            .on('mouseout', unhighlightTrain);
          
        rows.selectAll('td.dest')
          .text((d) => getTrip(d.tripId).trip_headsign)
          .attr('title', (d) => getTrip(d.tripId).trip_headsign)
          .style('white-space', 'nowrap')
          .style('overflow', 'hidden')
          .style('text-overflow', 'ellipsis');
        rows.selectAll('td.stop')
            .text((d) => d.latestUpdate.stopId)
            .attr('title', (d) => getStop(d.latestUpdate.stopId).stop_name);
        rows.selectAll('td.time').text((d) => { 
          var time = +d.latestUpdate.arrival.time;
          var date = new Date(time*1000);
          return date.toLocaleTimeString("en-us", {
            hour12: false,
            formatMatcher: "basic",
            timeZone: "America/Los_Angeles"
          });
        });
        rows.selectAll('td.delay').text((d) => { 
          var delay = d.latestUpdate.arrival.delay;
          if (delay == 0) { 
            return "-"; 
          } else { 
            // Format delay (e.g. '+1m2s' or '+30s' or '-5s')
            if (delay > 0) {
              str = "+";
            } else {
              str = "-";
            }
            delay = Math.abs(delay)
            if (delay > 60) {
              str += Math.floor(delay/60) + "m ";
              delay = delay % 60;
            }
            str += delay + "s";
            return str; 
          }
        });

        var image_icon_size = 20;
        var trains = d3.select('#bart-trains').selectAll('image')
                       .data(updates, (d) => d.tripId);

        trains.transition()
              .duration(500)
              .attr('x', (d) => projectionX(d.latestLon) - image_icon_size/2)
              .attr('y', (d) => projectionY(d.latestLat) - image_icon_size/2);


        trains.enter().append('image')
              .attr('xlink:href', 'img/train.svg')
              .attr('width', image_icon_size)
              .attr('height', image_icon_size)
              .attr('x', (d) => projectionX(d.latestLon) - image_icon_size/2)
              .attr('y', (d) => projectionY(d.latestLat) - image_icon_size/2);

        /* Draw a border around a train icon */
        function highlightTrain(d) {
          unhighlightTrain();

          var strokeWidth = 5;
          var rectSize = image_icon_size + 2 * strokeWidth;
          d3.select('#bart-trains')
            .append('rect')
            .attr('width', rectSize)
            .attr('height', rectSize)
            .attr('x', projectionX(d.latestLon) - rectSize/2)
            .attr('y', projectionY(d.latestLat) - rectSize/2)
            .attr('fill', 'none')
            .attr('stroke', "#" + getRoute(getTrip(d.tripId).route_id).route_color)
            .attr('stroke-width', strokeWidth);
        }

        function unhighlightTrain() {
          highlightedTrain = d3.select('#bart-trains').selectAll('rect').remove();
        }
         
      }

      function updateLoop() {
        // Fetch real-time data and update all views
        updateRealTime();

        // Schedule this function for continuous updates
        setTimeout(updateLoop, 2000);
      }

      async function init() {
        // Load GTFS csv files into global vars
        // We await for this call because other stuff depends on GTFS
        await loadGtfs();

        // This is the SVG where we will render the map
        var svg = d3.select('#map');

        initMapProjection(svg);

        // Render Bay area map
        renderBayAreaMap(svg);

        // Render BART map
        renderBartMap(svg);

        // End by firing off the real-time updates
        updateLoop();
      } 
        
        
    </script>
    <style type="text/css">
      * { box-sizing: border-box; }

      #map {
        border: 1px solid #ccc;
      }

      .label {
        font-size: 0.8em;
      }

      .stop {
        font-weight: bold;
      }

      .grid{
        display: table;
        width: 100%;
        border-spacing:.5em;
        height: 50em;
      }
      @media (min-width: 80em) {
        .col {
          display: table-cell;
          border: #666 1px solid;
          vertical-align: top;
          padding: 1em;
        }
        .sides {
          width: 25%;
        }
        .middle {
          width: 50%;
          padding: 0;
        }
      }
      #current-div {
        height: 40em;
        overflow-y: scroll;
      }
      #current-tab {
        font-size: 0.9em;
      }
      thead {
        font-weight: bold;
      }
    </style>
  </head>
  <body onload="init()">
    <h1>BART: System Information</h1>
    <div class="grid">
      <div class="col sides">
        <h2>Current Trips</h2>
        <div id="current-div">
          <table id="current-tab" style="table-layout: fixed;">
            <thead><td>Trip</td><td>Stop</td><td>Arrival</td><td>Delay</td></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <div class="col middle">
        <svg id="map" width="100%" height="100%" viewBox="0 0 800 800">
          <g id="bay-area" />
          <g id="bart-system"></g>
          <g id="bart-trains"></g>
          <g id="bart-alerts"></g>
        </svg>
      </div>
      <div class="col sides">
        <h2>Station Info</h2>
        <p>More stuff to be added...</p>
      </div>
    </div>
    <h2>Statistics</h2>
    <p>More stuff to be added...</p>
  </body>
</html>